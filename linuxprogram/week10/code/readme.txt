exit.c运行结果:
生成了test.txt，但test.txt的内容为空,.因为标准I/O函数是带缓存的，进行fputs的时候是先向缓存中写的，只有当缓存满的时候才会刷新的缓冲区的。从以上我们发现，当进程退出时，执行_exit()函数并没有刷新缓冲区的数据，而是直接终止进程的。
将exit前的下划线去掉则可成功写入test.txt

2.c运行结果:
若是执行./2 exit 则依次输出。
若是执行./2 _exit 则不输出。

3.c运行结果:
gv不动
4.c运行结果:
g++,v=0.出现段错误.

2-1.c(周二的代码)运行结果:
最后一行：
若是执行./2 exit 
若是执行./2 _exit 输出constructor同时不向test.dat输入文字。
若是执行return0
若是啥都没有，效果和exit一样，如下
-------cons---------
print：data from line buffer
-------callback2-------
-------callback1-------
--------des------------

fork派生进程后，父子运行顺序由操作系统算法决定。出现漏洞：子在父先忘，出现孤儿进程
vfork自进程只有在执行exit和_exit时才与父进程分离，否则父子进程共用一套资源。严格规定：子进程先于父进程运行，直至子进程结束。
子进程中止仅能通过_exit直接中止，也能用exit，但不能用return，因为会释放局部资源的栈。

2-2.c运行结果：
父进程先跑，线性地址相同，说明fork复制的表资源相同，


